<?php

/**
 * SendOauth2B Wrapper For Microsoft and Google OIDC/OAUTH2 For PHPMailer
 * PHP Version 5.5 and greater
 *
 * @category Class
 * @see      https://github.com/PHPMailer/PHPMailer/ The PHPMailer GitHub project
 * @author   Max Stewart (decomplexity) <SendOauth2@decomplexity.com>
 * @copyright  2021 Max Stewart
 * @license  MIT
 */
      namespace decomplexity\SendOauth2;

      use PHPMailer\PHPMailer\OAuth;

/**
 * SendOauth2B Class Doc Comment
 * @category Class
 * @package  SendOauth2B
 * @author   Max Stewart (decomplexity) <SendOauth2@decomplexity.com>
 * @license  MIT
 * @note SendOauth2B provides website-wide settings for SendOauth2A
 * @note supports OAuth2 ('XOAUTH2'), Basic AUTH ('LOGIN') and other AUTHNs
 */

class SendOauth2B
{
    /**
     *
     * OAUTH2 WEBSITE-WIDE PARAMETERS
     *
     */

    /**
     * Email address of XOAUTH2 resource owner
     *
     * @var string
     */
    protected $username = '';
	
    /**
     * Tenant GUID or domain name
	 * Needed for client_credentials grant where e.g. 'common' is not allowed
     *
     * @var string
     */
	protected $tenant = '';
	

    /**
     * XOAUTH2 client ID generated by AAD registration
     *
     * @var string
     */
    public $clientId = '';

    /**
     * XOAUTH2 client secret generated by AAD registration
     *
     * @var string
     */
    public $clientSecret = '';

   /**
	* operands for $provider. Techncally are extensions of
	* TheLeague's generic $provider
	*/
	
	protected $clientCertificatePrivateKey = NULL;
	protected $clientCertificateThumbprint = NULL;

    /**
     * Needed for offline generation of the XOAUTH2 refresh token.
     * Should not be needed if the refresh token is an everlasting one
     *
     * @var string
     */
    protected $redirectURI = '';
	
   /**
	* for GSuite accounts only - used to restrict access to a specific domain
	* @var string
    */
	protected $hostedDomain;
	
    /**
     * XOAUTH2 refresh token initially generated offline by SendOauth2D
     * but dynamically regenerated afterwards
     *
     * @var string
     */
    protected $refreshToken = '';

    /**
     * scope value passed from SendOauthC 
     * needed by PHPMailer Oauth class
     * @var string
     */
	protected $scope="";

    /**
    *
    * BASIC AUTHENTICAION PARAMETERS
    *
    */

    /**
     * name prefix to sender address; set in SendOuth2D and used by default in SendOuth2A
     * if the caller of SendOauth2A does not specify a fromName
     *
     * @var string
     */
    protected $fromNameDefault = '';

    /**
     * sender email address. Normnally the service provider will mandate that
     * this is a primary address or alias registered as the email address.
     * It is the SMTP 'Userid' and also used for XOAUTH2 authentication
     *
     * @var string
     */
    public $mailSMTPAddress = '';


    /**
     * Basic AUTH password. Not used for Oauth2
     *
     * @var string
     */
    protected $SMTPPassword = '';


   /**
    * MISC
    */

    /**
     instantiation of PHPMailer
    */
    protected $mail;


    /**
     * instantiation of provider
     */
    protected $provider;

    /**
     * instantiation of SendOauthC
     * @var object
     */
    protected $Send_Oauth_C_obj;


    /**
     * XOAUTH2 or LOGIN - returned to SendOauth2A
     *
     * @var string
     */
    protected $authTypeSetting = "";
	
   /**
    * usually authorization_code grant (for OAuth2 only)
    * set inn SendOauth2D-settings. Alternative is e.g. 'client_credentials'
    * when MSFT supports SMTP.Send with ciient_credentials
    */
    protected $grantTypeValue = "";
	
	/**
     * Microsoft, Google or whatever
     *
     * @var string
     */
    protected $serviceProvider = "";

    /**
     * selects the AUTH type and parameters - from mainline module
     *
     * @var string
     */
    protected $mailAuthSet = "";

   /**
    filename prefix for the parameter file that is passed from running SendOauth2D
    */
    protected const OAUTH2_PARAMETERS_FILE = 'Oauth2parms';

   /**
    implode/explode array variables separator
    */
    protected const IMPLODE_GLUE = 'IMPLODE_GLUE';


    /**
     * __construct Method Doc Comment
     *
     * @category Method
     * @author     Max Stewart (decomplexity) <SendOauth2@decomplexity.com>
     */

    public function __construct($optionsB)
    {
        if (session_status() === PHP_SESSION_NONE) {
        session_start();
        }
	
	   $this->mailAuthSet = $optionsB['mailAuthSet'];
        $this->mailSMTPAddress = $optionsB['mailSMTPAddress'];
        $this->mail = $optionsB['mail'];
     /**
      * SMTPAddress (below) is used by Oauth class as username and by BAuth and PHPMailer as Logon address
      */

        $optionsC = file_get_contents(self::OAUTH2_PARAMETERS_FILE . "_" . $this->mailAuthSet . ".txt");
     /**
      * If the contents of the file were encrtypted by SendOauth2D, decrypt it here.
      * Just decrypt $optionsC
      */

        $optionsC1 = explode(self::IMPLODE_GLUE, $optionsC);

     /**
      * optionsC1 now contains the following parms that were originally saved by SendOauthD
      * note that implode and explode remove keys, so the order is important.
      * if any changes, cross-check with the list in SendAuth2D in method saveParameters
      */

        list(
        $this->tenant,		
        $this->clientId,
        $this->clientSecret,
	    $this->clientCertificatePrivateKey,
        $this->clientCertificateThumbprint, 
        $this->redirectURI,
        $this->serviceProvider,
        $this->authTypeSetting,
        $this->fromNameDefault,
        $this->SMTPAddressDefault,
        $this->SMTPPassword,
        $this->hostedDomain,
        $this->refresh,
        $this->refreshToken,
	    $this->grantTypeValue,
        ) = $optionsC1;

      /**
       * to avoid using positional parameters, e.g. [0] for ease of maintenance use indexed parameters instead...
       * and for details of refresh, see SendOauthC;
       */
        $optionsC2 = [
		  'tenant' => $this->tenant,          
		  'clientId' => $this->clientId,
          'clientSecret' => $this->clientSecret,
          'clientCertificatePrivateKey' => $this->clientCertificatePrivateKey,
          'clientCertificateThumbprint' => $this->clientCertificateThumbprint, 
	      'redirectURI' => $this->redirectURI,
          'serviceProvider' => $this->serviceProvider,
          'authTypeSetting' => $this->authTypeSetting,
	      'hostedDomain' => $this->hostedDomain,
	      'refresh' => false,
	      'grantTypeValue' => $this->grantTypeValue,

       /**
        *
        * using  'accessType' = 'offline' and 'accessPrompt' = 'none'
        * should not be needed unless the refresh token is one that can expire
        */

          ];


        $this->Send_Oauth_C_obj = new SendOauth2C($optionsC2);
	    $this->scope = $this->Send_Oauth_C_obj->getScope(); 
        $this->mail->Host = $this->getSMTPserver();
        $this->mail->AuthType = $this->authTypeSetting;        // usually XOAUTH2 or LOGIN

      /**
       * mailSMTPAddress should normally NOT be set in global but allowed to take the SendOauth2 default,
       * unless pro tem you want to override the SendOauth2 default
       * Note that neither MSFT nor Google will will allow sending from 'arbitrary' addresses
       * NB: PHPMailer mail->Username is an SMTP ADDRESS
       */

        if (empty($this->mailSMTPAddress)) {
            $this->mailSMTPAddress = $this->SMTPAddressDefault;
        }
        $this->mail->Username = $this->mailSMTPAddress; // SMTP sender email address (MSFT or Google email account)

      /**
       * now Oauth2 authenticate, but only if XOAUTH2 !
       */

        if ($this->authTypeSetting == "XOAUTH2") {
            $this->mail->refresh_token = $this->refreshToken;
            $doit = $this->authenticate();
        } else {
      /**
       * Give PHPMailer the SMTP password only if AUTHN is either CRAM-MD5, LOGIN or PLAIN
       * Google's PLAIN-CLIENTTOKEN OAUTHBEARER and XOAUTH[1] are unsupported
       */
            $this->mail->Password = $this->SMTPPassword;
        }

     /**
      * ends __construct
      */
    }



    protected function authenticate()
    {
           $this->provider = $this->getProvider();
           $this->mail->setOAuth(
               new OAuth(
                   [
                   'provider' => $this->provider,
                   'clientId' => $this->clientId,
                   'clientSecret' => $this->clientSecret,
	   			   'clientCertificatePrivateKey' => $this->clientCertificatePrivateKey, 
                   'clientCertificateThumbprint' => $this->clientCertificateThumbprint,
                   'refreshToken' => $this->refreshToken,
                   'userName' => $this->mailSMTPAddress,
				   'grantTypeValue' => $this->grantTypeValue, 
                   'scope' => $this->scope,
                    ]
               )
           );

        /**
         * ends authenticate method
         */
    }



     /**
     * getProvider retrieves the provider-package object (Azure, Google,...) from SendOauthC
     */

    public function getProvider()
    {
        return $this->Send_Oauth_C_obj->setProvider();

    /**
     * ends getProvider method
     */
    }


    /**
     * getSMTPserver retrieves the server domain name from SendOauthC
     * the server domain name cannot be assigned to $this->mail->Host there
     * as SendOauthC is instantiated both from here AND from SendOauthD
     * and SendOauthD is independent of PHPMailer and hence has no $mail object
     */

    public function getSMTPserver()
    {
        return $this->Send_Oauth_C_obj->setSMTPServer();

    /**
     * ends getsetSMTPServermethod
     */
    }


    /**
     * @return returns parameters and refresh token to SendOauth2A
     */
    public function getOauth2Settings()
    {
        return [
        'fromNameDefault' => $this->fromNameDefault,
        'mailSMTPAddress' => $this->mailSMTPAddress,
	    'authTypeSetting' => $this->authTypeSetting
        ];

    /**
     * ends getOauth2Settings method
     */
    }


   /**
    * takes an updated refresh token from Theleague's league/oauth2-client/src/Token/AccessToken.php
	* and rewrites the OAUTH2_PARAMETERS_FILE as originally read (above) but 
	* now containing the new refresh token
	* if the League\\OAuth2\\Client\\Token\AccessToken one-line change is not implemented,
	* it will be detected (below) and the existing refresh token not modified
    */
    public function storeNewRefreshToken() 
    {
	/** 
	 check if key exists - use a focused key to avoid any clash in League or related code
	 */
        $key = "League\\OAuth2\\Client\\Token" . "\\updatedRefreshToken";
        if (array_key_exists($key,$_SESSION))
        {
        $nrt = $_SESSION[$key];

	/** 
	 check if value was not empty
	 */
        if (!empty($nrt)) {
	   
        $optionsD1 = [
        $this->tenant, 
        $this->clientId,
        $this->clientSecret,
        $this->clientCertificatePrivateKey, 
        $this->clientCertificateThumbprint, 
    	$this->redirectURI,
        $this->serviceProvider,
        $this->authTypeSetting,
        $this->fromNameDefault,
        $this->SMTPAddressDefault,
        $this->SMTPPassword,
        $this->hostedDomain,
        $this->refresh,
        $nrt,
	    $this->grantTypeValue,
        ];
    /** 
     Don't override $this->refreshToken as having the old and new may help any diagnostics
     */

        $optionsD2 = implode(self::IMPLODE_GLUE, $optionsD1);

    /**
     * If the contents of the file (below) need encrypting, do it here.
     * Just encrypt $optionsD2
    */

    /**
     * write the completed set of parameters to file
     */
        file_put_contents(
            self::OAUTH2_PARAMETERS_FILE . "_" . $this->mailAuthSet . ".txt",
            $optionsD2
        );

        } // ends 'if token was found but value was not empty'

	 }    // ends 'if a token was actually found in  $_SESSION
	
	/**
     * ends storeNewRefreshToken method
     */
    }

   /**
    * ends class SendOauth2B
    */
}
